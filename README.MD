# Events Manager backendWelcome to the events manager API. You can use this API to access our event & creator API endpoints.The API is organized around REST. All request and response bodies, including errors, encoded in JSON.## Getting Started### Installing Dependencies#### Python 3.7Follow instructions to install the latest version of python for your platform in the [python docs](https://docs.python.org/3/using/unix.html#getting-and-installing-the-latest-version-of-python)#### Virtual EnviornmentInstructions for setting up a virual enviornment for your platform can be found in the [python docs](https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/)#### PIP Dependencies```bashpip install -r requirements.txt```Once you have your virtual environment setup and running, install dependencies by naviging to the `/backend` directory and running:## Database SetupWith Postgres running, restore a database using the events.psql file provided.From the backend folder in terminal run:## Running the serverFrom within the `backend` directory first ensure you are working using your created virtual environment.To run the server, execute:```bashexport FLASK_APP=app.pyexport FLASK_ENV=developmentflask run```Setting the `FLASK_ENV` variable to `development` will detect file changes and restart the server automatically.Setting the `FLASK_APP` variable to `flaskr` directs flask to use the `flaskr` directory and the `__init__.py` file to find the application. These commands put the application in development and directs our application to use the `__init__.py` file in our flaskr folder. Working in development mode shows an interactive debugger in the console and restarts the server whenever changes are made.  If running locally on Windows, look for the commands in the [Flask documentation](http://flask.pocoo.org/docs/1.0/tutorial/factory/).The application is run on `http://127.0.0.1:5000/` by default and is a proxy in the frontend configuration. ## TestingTo run the tests, run```dropdb em_test && createdb em_test && psql em_test < events.psqlpython test_app.py# heroku dbheroku loginheroku pg:reset DB_URL_HEREheroku psql DB_URL_HERE < ./em.psql --app=app_name```The first time you run the tests, omit the dropdb command. All tests are kept in that file and should be maintained as updates are made to app functionality. ## Deploy setup##Herokuheroku create satori-apiexport DJANGO_CONFIGURATION=Devexport DJANGO_SETTINGS_MODULE=mysite.settingsheroku config:set DJANGO_CONFIGURATION=Herokuheroku config:set DJANGO_SETTINGS_MODULE=satori.settings##postgres Herokuheroku addons:attach my-originating-app::DATABASE --app sushiheroku addons:create heroku-postgresql:hobby-devheroku pg:push mylocaldb HEROKU_POSTGRESQL_MAGENTA --app sushiheroku pg:push mylocaldb HEROKU_POSTGRESQL_MAGENTA --app sushihttps://devcenter.heroku.com/articles/heroku-postgresql#set-up-postgres-on-windowshttps://realpython.com/migrating-your-django-project-to-heroku/heroku config:set DEBUG_COLLECTSTATIC=1heroku config:set DISABLE_COLLECTSTATIC=1# login to your herokuheroku login# create new app if one doesn't yet existheroku create# create a new postgres database for your appheroku addons:create heroku-postgresql:hobby-dev --app=eman-udacitygit add .git commit -m "Re"git push heroku master## API Reference### Getting Started- Base URL: At present this app can only be run locally and is not hosted as a base URL. The backend app is hosted at the default, `http://127.0.0.1:5000/`, which is set as a proxy in the frontend configuration. - Authentication: TODO OAUTH### Error HandlingErrors are returned as JSON objects in the following format:```{  "error": 404,  "message": "Resource not found",  "success": false}```The API will return three error types when requests fail:- 400: Bad Request- 404: Resource Not Found- 422: unprocessable - 405: Method not allowed- 500: Server error### Endpoints ## AuthorsThembelani Mahlangu## Acknowledgements Udacity team, and Caryn McCarthy @ Udacity for guidance on best practices for API documentation