import dateparserimport datetimeimport markdownimport markdown.extensions.fenced_codeimport markdown.extensions.codehilitefrom pygments.formatters import HtmlFormatterfrom flask import Flask, request, abort, jsonifyfrom flask_sqlalchemy import SQLAlchemyfrom flask_cors import CORS, cross_originfrom auth import requires_auth, AuthErrorfrom models import setup_db, Event, Creatordef create_app(test_config=None):    # create and configure the app    app = Flask(__name__)    setup_db(app)    # set up CORS on all origins    CORS(app, resources={r"/*": {"origins": "*"}})    # set response headers    @app.after_request    def after_request(response):        response.headers.add("Access-Control-Allow-Headers", "Content-Type , Authorization, Data-Type",)        response.headers.add("Access-Control-Allow-Methods", "GET, PUT, POST, DELETE, PATCH, OPTIONS")        response.headers.add('Access-Control-Allow-Credentials', 'true')        return response    @app.route('/creators', methods=['GET'])    @requires_auth(permission='get:creator')    def creators(jwt):        """return all available creators"""        if request.method == 'GET':            creators = Creator.query.all()            return jsonify({                'success': True,                'creators': [creator.format() for creator in creators]            })    @app.route('/creatorEvents/<int:creator_id>', methods=['GET'])    @requires_auth(permission='read:events')    def get_events_by_creator(jwt,creator_id):        """return list of events filtered by creator"""        # filter event by creator, as is stored as varchar in events, use str        events = Event.query.filter(Event.creator_id == str(creator_id)).all()        creator = Creator.query.filter(Creator.id == creator_id).one_or_none()        if (events or creator) is None:            return abort(404)        else:            return jsonify({                'success': True,                'creator': creator.format_short(),                'events': [event.format() for event in events]            })    # todo post endpoint will be only accesible by admins,    # on first sign up a creator obj should be created with id and email    @app.route('/creators', methods=['POST'])    @requires_auth(permission='post:creator')    def add_creator(jwt):        """        POST: creates new event        """        if request.method == 'POST':            body = request.get_json()            email = body.get('email', None)            age = body.get('age', None)            phone = body.get('phone', None)            try:                # reject if any of the fields are missing                if email is None or phone is None:                    abort(422)                # create a new creator                creator_obj = Creator(email=email, phone=phone, age=age)                creator_obj.insert()                return jsonify({                    'success': True,                    'events': [creator_obj.format()],                }), 200            except Exception as e:                abort(422)    @app.route('/creators/<creator_id>', methods=['PATCH'])    @requires_auth(permission='patch:creator')    def update_creator(jwt, creator_id):        if request.method == 'PATCH':            try:                creator = Creator.query.filter(Creator.id == creator_id).one_or_none()                body = request.get_json()                email = body.get('email', None)                gender = body.get('gender', None)                age = body.get('age', None)                phone = body.get('phone', None)                # if not found reject                if creator is None:                    abort(404)                creator.email = email if email is not None else creator.email                creator.gender = gender if gender is not None else creator.gender                creator.age = age if age is not None else creator.age                creator.phone = phone if phone is not None else creator.phone                creator.update()                return jsonify({                    'success': True,                    'creator': [creator.format()],                })            except Exception as e:                abort(422)    @app.route('/creators/<creator_id>', methods=['DELETE'])    @requires_auth(permission='delete:creator')    def delete_creator(jwt, creator_id):        if request.method == 'DELETE':            try:                creator = Creator.query.filter(Creator.id == int(creator_id)).one_or_none()                if creator is None:                    abort(404)                creator.delete()                return jsonify({                    'success': True,                    'delete': creator_id,                }), 200            except Exception as e:                print(e)                abort(422)    @app.route('/events', methods=['GET'])    def public_retrieve_events():        """Public endpoint to return all available events"""        if request.method == 'GET':            try:                events = Event.query.all()                return jsonify({                    'success': True,                    'events': [event.format() for event in events],                    'total_events': len(events)                }), 200            except Exception as e:                print(e)                abort(404)    @app.route('/events-detail', methods=['GET'])    @requires_auth(permission='get:events-detail')    def retrieve_events(jwt):        """Return all available events in long format, requires auth"""        if request.method == 'GET':            try:                events = Event.query.all()                return jsonify({                    'success': True,                    'events': [event.detail_format() for event in events]                }), 200            except:                abort(422)    @app.route('/events', methods=['POST'])    @requires_auth(permission='create:events')    def add_events(jwt):        """Creates new event"""        if request.method == 'POST':            body = request.get_json()            title = body.get('title', None)            date = body.get('date', None)            category = body.get('category', None)            img = body.get('img', None)            creator_id = body.get('creator_id', None)            try:                # reject if any of the fields are missing                if title is None or date is None:                    abort(422)                # clean up the date                parsed_date = dateparser.parse(date)                now = datetime.datetime.now()                if parsed_date < now:                    abort(422)                # create a new event, and relation                event_obj = Event(title=title, date=parsed_date, category=category, img=img, creator_id=int(creator_id))                event_obj.insert()                return jsonify({                    'success': True,                    'event': [event_obj.format()],                }), 200            except Exception as e:                abort(422)    @app.route('/events/<event_id>', methods=['PATCH'])    @requires_auth(permission='update:events')    def update_event(jwt, event_id):        """Updates an existing event"""        if request.method == 'PATCH':            try:                event = Event.query.filter(Event.id == event_id).one_or_none()                body = request.get_json()                title = body.get('title', None)                category = body.get('category', None)                img = body.get('image', None)                parsed_date = None                date = body.get('date', None)                # if not found reject                if event is None:                    abort(404)                # clean up the date                if date is not None:                    parsed_date = dateparser.parse(date)                    now = datetime.datetime.now()                    if parsed_date < now:                        abort(422)                event.title = title if title is not None else event.title                event.date = parsed_date if parsed_date is not None else event.date                event.category = category if category is not None else event.category                event.img = img if img is not None else event.img                if title is not None:                    event.title = title                event.update()                return jsonify({                    'success': True,                    'events': [event.format()],                })            except:                abort(422)    @app.route('/events/<event_id>', methods=['DELETE'])    @requires_auth(permission='delete:events')    def delete_events(jwt, event_id):        if request.method == 'DELETE':            try:                event = Event.query.filter(Event.id == int(event_id)).one_or_none()                if event is None:                    abort(404)                event.delete()                return jsonify({                    'success': True,                    'delete': event_id,                }), 200            except Exception as e:                print(e)                abort(422)    @app.route("/")    def index():        readme_file = open("README.md", "r")        md_template_string = markdown.markdown(            readme_file.read(), extensions=["fenced_code", "codehilite"]        )        # Generate css for syntax highlighting        formatter = HtmlFormatter(style="emacs", full=True, cssclass="codehilite")        css_string = formatter.get_style_defs()        md_css_string = "<style>" + css_string + "</style>"        md_template = md_css_string + md_template_string        return md_template    # error handlers    @app.errorhandler(404)    def not_found(error):        return jsonify({            "success": False,            "error": 404,            "message": "Resource not found",        }), 404    @app.errorhandler(422)    def unprocessable(error):        return jsonify({            "success": False,            "error": 422,            "message": "unprocessable",        }), 422    @app.errorhandler(400)    def bad_request(error):        return jsonify({            "success": False,            "error": 400,            "message": "bad request",        }), 400    @app.errorhandler(500)    def bad_request(error):        return jsonify({            "success": False,            "error": 500,            "message": "server error",        }), 500    @app.errorhandler(405)    def bad_request(error):        return jsonify({            "success": False,            "error": 405,            "message": "method not allowed",        }), 405    @app.errorhandler(AuthError)    def not_found(error):        print(error.error)        return jsonify({            "success": False,            "error": error.error['code'],            "message": error.error['description'],        }), error.status_code    return appapp = create_app()if __name__ == '__main__':    app.run()